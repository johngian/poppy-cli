from .resource import Resource
from itertools import cycle
from typing import Any, Optional

roundrobin_failover = cycle

class Connection:
    port: Any = ...
    virtual_host: str = ...
    connect_timeout: int = ...
    uri_prefix: Any = ...
    declared_entities: Any = ...
    cycle: Any = ...
    transport_options: Any = ...
    failover_strategy: str = ...
    heartbeat: Any = ...
    resolve_aliases: Any = ...
    failover_strategies: Any = ...
    hostname: Any = ...
    userid: Any = ...
    password: Any = ...
    ssl: Any = ...
    login_method: Any = ...
    alt: Any = ...
    def __init__(self, hostname: str = ..., userid: Optional[Any] = ..., password: Optional[Any] = ..., virtual_host: Optional[Any] = ..., port: Optional[Any] = ..., insist: bool = ..., ssl: bool = ..., transport: Optional[Any] = ..., connect_timeout: int = ..., transport_options: Optional[Any] = ..., login_method: Optional[Any] = ..., uri_prefix: Optional[Any] = ..., heartbeat: int = ..., failover_strategy: str = ..., alternates: Optional[Any] = ..., **kwargs: Any) -> None: ...
    def switch(self, conn_str: Any) -> None: ...
    def maybe_switch_next(self) -> None: ...
    def register_with_event_loop(self, loop: Any) -> None: ...
    def connect(self): ...
    def channel(self): ...
    def heartbeat_check(self, rate: int = ...): ...
    def drain_events(self, **kwargs: Any): ...
    def maybe_close_channel(self, channel: Any) -> None: ...
    def collect(self, socket_timeout: Optional[Any] = ...) -> None: ...
    def release(self) -> None: ...
    close: Any = ...
    def ensure_connection(self, *args: Any, **kwargs: Any): ...
    def completes_cycle(self, retries: Any): ...
    def revive(self, new_channel: Any) -> None: ...
    def ensure(self, obj: Any, fun: Any, errback: Optional[Any] = ..., max_retries: Optional[Any] = ..., interval_start: int = ..., interval_step: int = ..., interval_max: int = ..., on_revive: Optional[Any] = ...): ...
    def autoretry(self, fun: Any, channel: Optional[Any] = ..., **ensure_options: Any): ...
    def create_transport(self): ...
    def get_transport_cls(self): ...
    def clone(self, **kwargs: Any): ...
    def get_heartbeat_interval(self): ...
    def info(self): ...
    def __eqhash__(self): ...
    def as_uri(self, include_password: bool = ..., mask: str = ..., getfields: Any = ...): ...
    def Pool(self, limit: Optional[Any] = ..., **kwargs: Any): ...
    def ChannelPool(self, limit: Optional[Any] = ..., **kwargs: Any): ...
    def Producer(self, channel: Optional[Any] = ..., *args: Any, **kwargs: Any): ...
    def Consumer(self, queues: Optional[Any] = ..., channel: Optional[Any] = ..., *args: Any, **kwargs: Any): ...
    def SimpleQueue(self, name: Any, no_ack: Optional[Any] = ..., queue_opts: Optional[Any] = ..., queue_args: Optional[Any] = ..., exchange_opts: Optional[Any] = ..., channel: Optional[Any] = ..., **kwargs: Any): ...
    def SimpleBuffer(self, name: Any, no_ack: Optional[Any] = ..., queue_opts: Optional[Any] = ..., queue_args: Optional[Any] = ..., exchange_opts: Optional[Any] = ..., channel: Optional[Any] = ..., **kwargs: Any): ...
    def supports_exchange_type(self, exchange_type: Any): ...
    def __copy__(self): ...
    def __reduce__(self): ...
    def __enter__(self): ...
    def __exit__(self, *args: Any) -> None: ...
    @property
    def qos_semantics_matches_spec(self): ...
    @property
    def connected(self): ...
    @property
    def connection(self): ...
    @property
    def default_channel(self): ...
    @property
    def host(self): ...
    @property
    def transport(self): ...
    def manager(self): ...
    def get_manager(self, *args: Any, **kwargs: Any): ...
    def recoverable_connection_errors(self): ...
    def recoverable_channel_errors(self): ...
    def connection_errors(self): ...
    def channel_errors(self): ...
    @property
    def supports_heartbeats(self): ...
    @property
    def is_evented(self): ...
BrokerConnection = Connection

class ConnectionPool(Resource):
    LimitExceeded: Any = ...
    close_after_fork: bool = ...
    connection: Any = ...
    def __init__(self, connection: Any, limit: Optional[Any] = ..., **kwargs: Any) -> None: ...
    def new(self): ...
    def release_resource(self, resource: Any) -> None: ...
    def close_resource(self, resource: Any) -> None: ...
    def collect_resource(self, resource: Any, socket_timeout: float = ...): ...
    def acquire_channel(self, block: bool = ...) -> None: ...
    def setup(self) -> None: ...
    def prepare(self, resource: Any): ...

class ChannelPool(Resource):
    LimitExceeded: Any = ...
    connection: Any = ...
    def __init__(self, connection: Any, limit: Optional[Any] = ..., **kwargs: Any) -> None: ...
    def new(self): ...
    def setup(self) -> None: ...
    def prepare(self, channel: Any): ...
